<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <title>字幕用 自然改行ツール</title>
    <style>
        body { font-family: sans-serif; padding: 20px; max-width: 800px; margin: 40px auto; background-color: #f4f7f6; color: #333; }
        h1, h2 { color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 5px; margin-top: 30px; }
        .container { display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 20px; }
        .section { flex: 1; min-width: 300px; }
        textarea { width: 100%; min-height: 150px; margin-bottom: 15px; padding: 10px; border: 1px solid #ccc; border-radius: 5px; box-sizing: border-box; font-size: 0.95rem; line-height: 1.5; }
        #output { white-space: pre-wrap; border: 1px solid #ddd; padding: 15px; background: #fff; min-height: 150px; font-family: 'Consolas', 'Monaco', monospace; border-radius: 5px; overflow-x: auto; box-shadow: inset 0 1px 3px rgba(0,0,0,0.1); }
        .controls { background-color: #eaf2f8; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .controls div { margin-bottom: 12px; }
        .controls label { display: block; margin-bottom: 5px; font-weight: bold; color: #555; }
        .controls input[type="number"],
        .controls select { width: 80px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 0.9rem; }
        .controls input[type="radio"] { margin-right: 8px; }
        .controls input[type="checkbox"] { margin-right: 8px; transform: scale(1.1); }
        .controls .radio-group label { display: inline-block; margin-right: 15px; font-weight: normal; }
        button { padding: 12px 25px; background-color: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 1.1rem; transition: background-color 0.3s ease; display: block; width: 100%; max-width: 250px; margin: 20px auto 0; }
        button:hover { background-color: #2980b9; }
        button:active { transform: translateY(1px); }
        .copy-button { background-color: #27ae60; margin-top: 10px; }
        .copy-button:hover { background-color: #229954; }
        @media (max-width: 768px) {
            .container { flex-direction: column; }
            button { max-width: 100%; }
        }
    </style>
</head>
<body>
    <h1>字幕用 自然改行ツール231</h1>

    <div class="container">
        <div class="section">
            <label for="inputText">入力テキスト:</label>
            <textarea id="inputText" placeholder="ここに字幕テキストを入力してください。日本語と英語の両方に対応しています。"></textarea>
        </div>

        <div class="section">
            <label for="output">出力結果:</label>
            <div id="output"></div>
            <button id="copyButton" class="copy-button">出力結果をコピー</button>
        </div>
    </div>

    <div class="controls">
        <h2>設定</h2>
        <div class="radio-group">
            <label>言語:</label>
            <input type="radio" id="langJapanese" name="language" value="japanese" checked />
            <label for="langJapanese">日本語</label>
            <input type="radio" id="langEnglish" name="language" value="english" />
            <label for="langEnglish">英語</label>
        </div>

        <div>
            <label for="maxChars">1行の最大文字数:</label>
            <input type="number" id="maxChars" value="15" min="10" />
        </div>
        <div>
            <label for="maxLines">1字幕の最大行数:</label>
            <input type="number" id="maxLines" value="2" min="1" max="5" />
        </div>

        <div id="japaneseOptions">
            <h3>日本語固有の設定</h3>
            <div>
                <input type="checkbox" id="avoidLineHeadPunctuation" checked />
                <label for="avoidLineHeadPunctuation">行頭禁則処理（句読点、閉じ括弧などが行頭に来ないようにする）</label>
            </div>
            <div>
                <input type="checkbox" id="preferPunctuationBreakJapanese" checked />
                <label for="preferPunctuationBreakJapanese">句読点（、。）での改行を優先</label>
            </div>
            </div>

        <div id="englishOptions" style="display: none;">
            <h3>英語固有の設定</h3>
            <div>
                <input type="checkbox" id="preferPunctuationBreakEnglish" checked />
                <label for="preferPunctuationBreakEnglish">句読点（.,!?など）での改行を優先</label>
            </div>
            <div>
                <input type="checkbox" id="avoidHyphenBreak" checked />
                <label for="avoidHyphenBreak">ハイフン接続語の途中改行を避ける</label>
            </div>
        </div>
    </div>

    <button id="processButton">改行処理を実行</button>

    <script>
        // DOM要素の取得
        const inputTextarea = document.getElementById('inputText');
        const outputDiv = document.getElementById('output');
        const maxCharsInput = document.getElementById('maxChars');
        const maxLinesInput = document.getElementById('maxLines');
        const langJapaneseRadio = document.getElementById('langJapanese');
        const langEnglishRadio = document.getElementById('langEnglish');
        const japaneseOptionsDiv = document.getElementById('japaneseOptions');
        const englishOptionsDiv = document.getElementById('englishOptions');
        const avoidLineHeadPunctuationCheckbox = document.getElementById('avoidLineHeadPunctuation');
        const preferPunctuationBreakJapaneseCheckbox = document.getElementById('preferPunctuationBreakJapanese');
        const preferPunctuationBreakEnglishCheckbox = document.getElementById('preferPunctuationBreakEnglish');
        const avoidHyphenBreakCheckbox = document.getElementById('avoidHyphenBreak');
        const processButton = document.getElementById('processButton');
        const copyButton = document.getElementById('copyButton');

        // 初期設定値の調整
        const defaultJapaneseMaxChars = 25; // ご要望に合わせて初期値を25に変更
        const defaultEnglishMaxChars = 42; 

        // 言語オプション表示の切り替え
        function toggleLanguageOptions() {
            if (langJapaneseRadio.checked) {
                japaneseOptionsDiv.style.display = 'block';
                englishOptionsDiv.style.display = 'none';
                maxCharsInput.value = defaultJapaneseMaxChars;
            } else {
                japaneseOptionsDiv.style.display = 'none';
                englishOptionsDiv.style.display = 'block';
                maxCharsInput.value = defaultEnglishMaxChars;
            }
        }

        // イベントリスナー
        langJapaneseRadio.addEventListener('change', toggleLanguageOptions);
        langEnglishRadio.addEventListener('change', toggleLanguageOptions);
        processButton.addEventListener('click', formatText);
        copyButton.addEventListener('click', copyOutput);

        // 初期表示
        toggleLanguageOptions();

        // 日本語の改行ロジック (大幅に修正)
        function formatJapaneseText(text, maxLen, options) {
            // 禁止句や連結句の途中改行防止リスト
            // このリストは必要に応じてさらに追加・調整してください
            const forbiddenMidWord = /[ァ-ヴーa-zA-Z0-9]$/; // カタカナ、英数字の末尾
            const forbiddenNextChar = /^[ァ-ヴーa-zA-Z0-9]/; // カタカナ、英数字の先頭

            const lines = [];
            let remaining = text.trim();

            while (remaining.length > 0) {
                if (remaining.length <= maxLen) {
                    lines.push(remaining);
                    break;
                }

                let bestCut = -1;
                let bestScore = -Infinity;

                // maxLen から探索を開始し、maxLen - N 文字まで遡って最適な改行位置を探す
                // Nは、許容できる「短くなる」文字数。ここでは8文字まで許容
                const searchStart = Math.min(maxLen, remaining.length);
                const searchEnd = Math.max(0, maxLen - 8); 

                for (let i = searchStart; i > searchEnd; i--) {
                    const part = remaining.slice(0, i);
                    const nextChar = remaining[i];
                    const charBeforeCut = remaining[i - 1]; // 改行前の文字
                    const charAfterCut = remaining[i];     // 改行後の文字 (行頭に来る文字)

                    let currentScore = 0;

                    // --- 厳禁ルール (これを満たさない候補は即座に除外) ---
                    // 行頭禁則処理
                    if (options.avoidLineHeadPunctuation) {
                        // 句読点、閉じ括弧、長音記号などが次の行頭に来るのを避ける
                        if (/[、。！？々ー・？！）」｝〕》〉’”）\]\)]/.test(charAfterCut)) {
                            continue;
                        }
                        // 開き括弧などの直後で改行しない
                        if (/[（「『【［｛〈“]/.test(charBeforeCut)) {
                            continue;
                        }
                    }

                    // 助詞の直前で改行しない (ただし、読点や句点の直前ならOK)
                    // 「は」「が」「を」「に」「と」「へ」「で」「から」「まで」「より」「も」
                    if (/[はがをにとへでからまでよりも]$/.test(charBeforeCut) && !/[、。！？]/.test(charBeforeCut)) {
                         continue; // 強く避ける
                    }
                    if (/[はがをにとへでからまでよりも]$/.test(charAfterCut)) {
                        continue; // 助詞が行頭に来るのも避ける
                    }

                    // 熟語、複合語、カタカナ語などの途中改行を強く避ける
                    // 漢字-漢字、漢字-ひらがな、ひらがな-漢字、カタカナ-カタカナ、漢字-カタカナ、カタカナ-漢字
                    // 例: 「世界」「等身大」「イメージされる」「片思い」
                    if (charBeforeCut && charAfterCut) {
                        // 漢字と漢字の結合
                        if (/[一-龠]$/.test(charBeforeCut) && /[一-龠]/.test(charAfterCut)) continue;
                        // 漢字とひらがな/カタカナの結合 (例: "世界"と"という")
                        if (/[一-龠]$/.test(charBeforeCut) && /[ぁ-んァ-ヶ]/.test(charAfterCut)) continue;
                        if (/[ぁ-んァ-ヶ]$/.test(charBeforeCut) && /[一-龠]/.test(charAfterCut)) continue;
                        // カタカナとカタカナの結合 (例: "イメージ"と"される")
                        if (/[ァ-ヶー]$/.test(charBeforeCut) && /[ァ-ヶー]/.test(charAfterCut)) continue;
                        // 英語単語の途中 (スペース以外)
                        if (/[a-zA-Z0-9]$/.test(charBeforeCut) && /[a-zA-Z0-9]/.test(charAfterCut)) continue;
                    }
                     // 数値や記号の途中改行を避ける（特に「100%」のような結合）
                    if (/[0-9]$/.test(charBeforeCut) && /[%円ドル]/.test(charAfterCut)) continue;


                    // --- スコアリング ---
                    // 句読点での改行は優先
                    if (options.preferPunctuationBreakJapanese) {
                        if (/[、。！？]/.test(charBeforeCut)) {
                            currentScore += 10; // 読点・句点の直後
                        }
                    }
                    // スペースでの改行はわずかに優先 (日本語ではあまり一般的ではないが)
                    if (charBeforeCut === ' ' && charAfterCut === ' ') {
                        currentScore += 2;
                    }

                    // なるべく maxLen に近い位置を優先
                    currentScore -= Math.abs(maxLen - i) * 0.5; // maxLenから離れるほどペナルティ

                    if (currentScore > bestScore) {
                        bestScore = currentScore;
                        bestCut = i;
                    }
                }

                // 最適な改行位置が見つからない場合、maxLenで強制改行（ただし、行頭禁則を考慮）
                if (bestCut === -1) {
                    let forceCut = maxLen;
                    // 強制改行でも行頭禁則文字が来ないように微調整
                    // 例: 次の文字が句読点なら、さらに1文字進める
                    if (remaining.length > forceCut && options.avoidLineHeadPunctuation) {
                        let nextCharForced = remaining[forceCut];
                        if (/[、。！？」｝〕》〉’”）\]\)]/.test(nextCharForced)) {
                            forceCut++;
                        }
                    }
                     // 最終的に有効な範囲でクリップ
                    bestCut = Math.min(forceCut, remaining.length);
                }

                lines.push(remaining.slice(0, bestCut));
                remaining = remaining.slice(bestCut).trimStart();
            }
            return lines;
        }

        // 英語の改行ロジック (変更なし、前回のまま)
        function formatEnglishText(text, maxLen, options) {
            const preferPunctuation = options.preferPunctuationBreakEnglish;
            const avoidHyphen = options.avoidHyphenBreak;
            const words = text.split(/(\s+)/); // スペースも保持して分割
            const lines = [];
            let currentLine = '';

            for (let i = 0; i < words.length; i++) {
                const word = words[i];
                
                // currentLineが空の場合（行の最初の単語）
                if (currentLine === '') {
                    currentLine += word;
                    continue;
                }

                // 次の単語（またはスペース）を追加した場合の長さを確認
                const potentialLine = currentLine + word;

                if (potentialLine.length > maxLen) {
                    // 行が長すぎる場合、現在の行を確定し、新しい行を開始
                    lines.push(currentLine.trim());
                    currentLine = word; // 新しい行は現在の単語から始める
                } else {
                    currentLine = potentialLine;
                }
            }
            // 最後に残った行を追加
            if (currentLine) {
                lines.push(currentLine.trim());
            }

            // ここから、さらに詳細な英語の改行ルールを適用（最終調整）
            const finalLines = [];
            let tempLine = ''; // 結合された単語を一時的に保持

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];

                // 前の行から引き継いだ部分がある場合
                if (tempLine) {
                    line = tempLine + line;
                    tempLine = '';
                }

                // ハイフン接続語の途中改行回避
                if (avoidHyphen && i < lines.length - 1) {
                    const nextRawWord = words.find(w => w.includes(lines[i+1].split(' ')[0])); // 次の行の最初の単語を元のwordsから探す (正確ではない場合あり)
                    if (line.endsWith('-') && !/\s/.test(lines[i+1][0])) { // ハイフンで終わっていて、次の行がスペースで始まらない場合
                         // 次の行の最初の単語と結合できるか試す
                        const combinedPotential = line + lines[i+1];
                        if (combinedPotential.length <= maxLen) { // 結合しても最大長を超えないなら結合
                            tempLine = combinedPotential; // 一時的に保持して次のループで処理
                            i++; // 次の行をスキップ
                            continue;
                        }
                    }
                }

                // 句読点での改行優先
                if (preferPunctuation) {
                    const lastChar = line[line.length - 1];
                    // 句読点（. , ! ?）で終わり、かつ最大文字数に余裕がある場合に改行を優先
                    if (/[.,!?]$/.test(lastChar) && line.length < maxLen && i < lines.length - 1) {
                        finalLines.push(line);
                        continue;
                    }
                }
                
                finalLines.push(line);
            }
            // 最後に残った tempLine があれば追加
            if (tempLine) {
                finalLines.push(tempLine);
            }

            // 1字幕あたりの最大行数で分割
            const resultSubtitles = [];
            let currentSubtitleLines = [];
            for(const line of finalLines) {
                currentSubtitleLines.push(line);
                if (currentSubtitleLines.length >= maxLines) {
                    resultSubtitles.push(currentSubtitleLines.join('\n'));
                    currentSubtitleLines = [];
                }
            }
            if (currentSubtitleLines.length > 0) {
                resultSubtitles.push(currentSubtitleLines.join('\n'));
            }

            return resultSubtitles;
        }

        // メインの整形関数
        function formatText() {
            const text = inputTextarea.value.trim();
            const maxChars = parseInt(maxCharsInput.value, 10);
            const maxLines = parseInt(maxLinesInput.value, 10); 

            if (!text) {
                outputDiv.textContent = 'テキストが空です。';
                return;
            }

            const currentLanguage = langJapaneseRadio.checked ? 'japanese' : 'english';

            let resultLines = [];
            const options = {
                avoidLineHeadPunctuation: avoidLineHeadPunctuationCheckbox.checked,
                preferPunctuationBreakJapanese: preferPunctuationBreakJapaneseCheckbox.checked,
                preferPunctuationBreakEnglish: preferPunctuationBreakEnglishCheckbox.checked,
                avoidHyphenBreak: avoidHyphenBreakCheckbox.checked
            };

            if (currentLanguage === 'japanese') {
                // 日本語の改行は、まず1行の長さに合わせて分割
                const singleLineFormatted = formatJapaneseText(text, maxChars, options);
                
                // その後、1字幕あたりの最大行数で分割
                let currentSubtitle = [];
                for (let i = 0; i < singleLineFormatted.length; i++) {
                    currentSubtitle.push(singleLineFormatted[i]);
                    if (currentSubtitle.length >= maxLines || i === singleLineFormatted.length - 1) {
                        resultLines.push(currentSubtitle.join('\n'));
                        currentSubtitle = [];
                    }
                }
            } else {
                // 英語の改行
                resultLines = formatEnglishText(text, maxChars, options);
            }

            outputDiv.textContent = resultLines.join('\n\n'); // 各字幕ブロックを2つの改行で区切る
        }

        // 出力結果をコピーする関数
        function copyOutput() {
            const textToCopy = outputDiv.textContent;
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(textToCopy).then(() => {
                    alert('出力結果をクリップボードにコピーしました！');
                }).catch(err => {
                    console.error('クリップボードへのコピーに失敗しました', err);
                    fallbackCopyTextToClipboard(textToCopy);
                });
            } else {
                fallbackCopyTextToClipboard(textToCopy);
            }
        }

        // navigator.clipboard が使えない場合のフォールバック
        function fallbackCopyTextToClipboard(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed'; 
            textarea.style.left = '-9999px';
            document.body.appendChild(textarea);
            textarea.focus();
            textarea.select();
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    alert('出力結果をクリップボードにコピーしました！');
                } else {
                    alert('クリップボードへのコピーに失敗しました。手動でコピーしてください。');
                }
            } catch (err) {
                console.error('Fallback: クリップボードへのコピーに失敗しました', err);
                alert('クリップボードへのコピーに失敗しました。手動でコピーしてください。');
            }
            document.body.removeChild(textarea);
        }

        // 初期テキストをセット
        inputTextarea.value = `「片想い世界」というタイトルを聞いて、みなさまはどのような物語をイメージされるでしょうか？冒頭から、仲良し姉妹のような女性3人の等身大の暮らしぶりが映し出されることで、平凡な日々の幸せを描く作品かと思いきや、誰もが驚く意外な真相が用意されています。
ネタバレになってしまうため、ここで言えないのがもどかしい……！
題材となっているのは、どうにもならない“究極の片思い”。
This is an example of English subtitles. We expect it to be properly divided according to English rules, prioritizing word breaks and avoiding hyphens. Let's see how it handles a slightly longer sentence. It should work perfectly!`;

    </script>
</body>
</html>
